// import { BullModule, getQueueToken } from '@nestjs/bull';
// import { Test, TestingModule } from '@nestjs/testing';
// import { Queue } from 'bull';
// import { ArticleService } from '../article/article.service';
// import { EnqueueUrlModule } from '../enqueue-url/enqueue-url.module';
// import { Site } from '../site/site.entity';
// import { SiteModule } from '../site/site.module';
// import { CrawlerProcessor } from './rss-crawler.processor';
// import { CrawlerService } from './rss-crawler.service';
// import {getRepositoryToken} from '@nestjs/typeorm';

// const testSite = {
//   name: 'RSS 2.0 Example',
//   url: 'http://static.userland.com/gems/backend/rssTwoExample2.xml',
// } as Site;
// const expectedFeed = `<?xml version="1.0"?>
// <!-- RSS generated by Radio UserLand v8.0.5 on 9/30/2002; 4:00:00 AM Pacific -->
// <rss version="2.0" xmlns:blogChannel="http://backend.userland.com/blogChannelModule">`;

// describe('CrawlerProcessor', () => {
//   let processor: CrawlerProcessor;
//   let queue: Queue;

//   beforeEach(async () => {
//     const fakeProcessor = jest.fn();
//     const module: TestingModule = await Test.createTestingModule({
//       providers: [
//         CrawlerService,
//         CrawlerProcessor,
//         {
//           // ArticleService needs database access which have to be mocked
//           provide: ArticleService,
//           useValue: {
//             create: jest.fn().mockReturnValue(null),
//           },
//         },
//         {
//           provide: getRepositoryToken(Site),

//           // define all the methods that you use from the siteRepo
//           // give proper return values as expected or mock implementations, your choice
//           useValue: {
//             create: jest.fn().mockReturnValue(testSite1),
//             save: jest.fn().mockResolvedValue(testSite1),
//             find: jest.fn().mockResolvedValue(siteArray),
//             findOneOrFail: jest.fn().mockResolvedValue(testSite1),
//             delete: jest.fn().mockResolvedValue(true),
//           },
//         },
//       ],
//       imports: [
//         SiteModule,
//         EnqueueUrlModule,
//         // ArticleModule,
//         BullModule.registerQueue({
//           name: 'crawler',
//           redis: {
//             host: '0.0.0.0',
//             port: 6379,
//           },
//           processors: [fakeProcessor],
//         }),
//       ],
//     }).compile();

//     processor = module.get<CrawlerProcessor>(CrawlerProcessor);
//     queue = module.get<Queue>(getQueueToken('crawler'));
//   });

//   it('should be defined', () => {
//     expect(queue).toBeDefined();
//     expect(queue.name).toEqual('crawler');
//   });

//   describe('getFeed', () => {
//     it('should return a feed object', async () => {
//       expect(processor.getFeed(testSite)).resolves.toEqual(expectedFeed);
//     });
//   });

//   // describe('parseArticleCandidateList', () => {
//   //   it('should return an article DTO list for the feed', async () => {
//   //     expect(processor.parseArticleCandidateList(testSite, {})).resolves.toEqual(expectedFeed);
//   //   });
//   // });
// });
